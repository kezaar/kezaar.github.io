<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Locked Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title" content="If you're reading this, you are not invited and this information should not have been shared."/>
    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            font-family: 'Courier New', Courier, monospace;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #db3538;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #ff0000;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #bababa; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #bababa, #bababa);
            background: -moz-linear-gradient(right, #bababa, #bababa);
            background: -o-linear-gradient(right, #bababa, #bababa);
            background: linear-gradient(to left, #bababa, #bababa);
            font-family: 'Courier New', Courier, monospace;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid rgb(238, 31, 31);
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        .patchwork {
            opacity:0;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Page Locked</p>
                <p>enter the passphrase you received</p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="passphrase"
                       autofocus/>
            
                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>
            

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"df0fca6f457b9b2c6516b41ae7c72400ca4cdcded3d995dada48912a1749b74e872beecb78bff16de7b6a33cdd6738b95c5117bb78d68a62c17234ca9ec19383f3530251a17236b5858046fc59289f2133a34321e964dc0af78de5537ac9bca80ee47530cb5b86b67bb82bca09620a265a752836e881fb6344f6b39d31727699a018c4bd77b6c6a8a50664911b1415adcf09734e07edfec5ff20253d3a4498f36fb1937972539185b39d412e4c31ac7da7eadd10ccf29a5b5086cdaec8828e37e7c428c695e4a52a691ef63c40ed1b466138ee20720157e8f484377d6b1274ca66202f69855cd1ecc9d70b63883645d2d0ad895dba266560e3bb574715860085c821bfce615180e0ed2ddeb66cf860732488cceaaa78ef5123d74c5cf6d8ec71c2922e27339657439100a6e5cc17eb040464e989a5e963522c30272ba8ce16b115c19880558bc0da152b51ccdf04f172c27acd8f752ed6268f2f94adbd1d8926784a7d66e4968c2672b91cd28bef8f6eefdcf6ba526161f84c440319bfb35c772e0d1f052ed8ccc5c71f26ad3190f11b07a824487f78686b90e6504d56a178247a5de872af8b831395d8809f55690ed212e4dc0849a9c6ccda5302f56546f7996b3b7f5e94e3f9bbe49b032446b310b668b5c2faa60c4123ff4de5c4467eb11174e2ef22920a319d0b63ab97503aa29cb5af010e970134b5529e929541b4031529555e33180b302c02ed9aecb6ede268168a9ce34ae804a899fa7549119093dfbf3f8b446dae60327a83a1dcdb31bd48d5377319381f1513d49412168ac95d46508663f64abe89c1d3a61dea8d7be24afc1681fa6e4d93151a9c111d1cf26cd8ab2f29f711407b5871a1ebe85155ccf8669f26dfb4c2074b965bd08176f9b25af700c21931b5b8557c67e477616d1bbf3bf8564143798696352c5dd3c14ce646c7b335581249c128309ea35548ffd0cf78208c15b6ebe193097a870a039778f0eb51c70738f9c2057fed56cacaa1de81563b92061c62a10d41379ee49a8f5a2efbd589a999424a106f12a5e742961db586937c514ad0d52901d077cd12c1d57188cc68e7f93027ff0ebbe437e78bac89d7c0147bcf68b18266ff3dba32310cc1407b648e09abb7379dc729741398636b96f6b84bfe75ce7d37187f464fc3cf4f0a3d0f23029b9ec37af78ee45e6b9f1ac0db7c146eee1aec216134e6d72d863fe23dc876e3f157736c50b7d38dc20d89a594b9c353ef016d5312011095d2d25b87a2e23d7acdfaaa3050c2bdd3c1762ca90efff003c91643b77e6da9abacd0669926fb78b7cb02fb520d13ba5b312022df851cad1901248f5abb72bedcb16c40fbbb37448464fa44479e69995ea261e5c8f67f2b8ebd0311ea4c1eac243ba4349d1ff1cc9fd55d9b569208662b58a2efdaf73a86c71c61fd371daacd2d150682b4d65e4e7f76f8ccc28a964a8a1690bba39765a96fa5765f2fa2d45c66f61a94810cb17130858199d98bed5c16d780274e5ca2fcd8fcdef723a9421282c36f504ab1ac03ef32314f02970c08adbd54d705ce22f100b2f51d4aab609825b0b947e70381eaad2861496288b7c857ca0aedc7967bcac01d2fa374e10f2e4c376ff88633559cc942f232c3c9f8ca0e56c236e12f3a6d83657d71ec791ce4fcb7f67a138a8b086f822a66467a0d24b73d51e3b84f863d14e9c358c25e95a6ea7c5cf815471592b459a2858fe4ab57766311b7bd3d0b6eae88fa2aa00c57393edcbcedfbe1d65b4f556611489063cd66ac356faea9106153ed03281810010843c17cce9535238f70eb89e1ff21434afb1537ce23b36fc73f4ed74c7f70d6c874b3a9bbb7b260f33cb5c9ec2cfec1a03ca277ad2e4401fc465f2c0d45d2bc1a9d2915995971c8a471c93a0191f5776debc70cfda5807ce0f3b334bfc8bc933427afde771888af23453ff5ede8d56604a07ccdc83fdf940a7fe8e660a095bb2bf1a37231c27abd4359e5d86cb57f7266fe05fa2ddb3cb799079df3ea85ae5e00e3d229ee9e7447879dd66b4604285697f3a178ff9316b6a7afa64a16d676d951ecda43fee72a930716af3058e9be2264dc5afccd47d861f4f0fc553c86da52d9838c8bc6dd13d4e0a8715116240b71764b83fb446733863690d5c39bce07eba4a654c17010e17045c5a90ff9a6ec86a46638b01f31178cb56d900eeb609928264ef70018a9758ff6985085c6309b6740076583f8a5b0b1bc4026668eb77cbcb3f4e6fe167bcf649574288ba2c1e1d6792f6040f87e8a094e517bb50da4fbd36f41dae460aa141cbb95d21901f85a50cd0663fa4d06b724d293be1557a4057cc902501f0936f6f4f1a0737d990a41515a318a1e5b7c496c4d6bed97e106cac62dd64674841c078075ebede1f5ffcae4c6f6c89ef9491dfcb992aadb546126eae424b097c79d8caa977d797058102c4e0714bd6676c60aae72c736eca05a57f150f3b0a51603e277d6452162aadc640d46534896957210d23c606329fc70d1dcfc5384341ff9ba266aab71065a33d9679244e8b302fab63775edfbc2ad8aed8812e8ba657c8907cf347e60894a3cfd3a3483d91c431ed086d18d1107e3e12a1a429d1e2f116b3f169f01016094282cd470d24470b6c2ee51e6b168e20346876dea14d022c72f059b0ebd7ceaa77fb21d0fb5a35b4681e2e16181f98e3560bd96ba6c766162fd664bea31e1df2cbf7d85a2af5bd45121fd9b53683dd9e4a6b49d84fcda0cff8432c84627aac1baf3d414174e9f3cba7d7615afd6ceb9f55b249180d455e9d42ba0748858146981b15c8b05018c7a7a5c061fc42ca0f70faf42c5054ad3f77ec2ef950690b537118a4ca579e1d6ccbb5da48c63b86daadbe2a0b65d6ccc6780401ed9c478ca015f204be2470469f64c7cce356848a62290ff81ac3ee609abb8de3c144b1212b26825c49464dfe38c2c5eb45c325d22a3f1fb1a1859075e0022289d70f5f747049b5a9334c8e840a44470a6ba1077584173722f10bbebd517690fab391da249c085b3970ab0eba44d83de88900a1c0e1fdd4a3cf7d966e98836fa989eef0dcbae9323dfc275e353880aaf49131ac0e673099548a045a49bcb2a6233daa87dba86e17b35690076e62775e5fe84c1a14df7781af79f28c75e7603b1132406e70c6b1a10c9b6ca448cdfaddaa8fcbf07ba22f3c16c18e88b5334f05f4d243a2abbc22d0a3c581479c7ae522187ad7eec9a004d49bc591c159836b0fa769aeb578e8828f39feb4dd8c19f56f4376cd616ee27215ae727b45f9208260ba51a117425b88ed3ae136f74927e5804cb0026b27ece61c7f5bff49c3105b0655c18d35d31b124911d4c17f8f15bde12da12cbac3b5dbdc2a2e699d92347903078edc898b657fce2fc86745e264f502dac2bb0c4ec150ef896139be044e6f45f9440e2a9decc0106faf93db4049f5b41d34f598f9caea58593e1b161dad0195fe98de6a96fa53bbc889e9f4f047c5addbd2b4f04d771a0116f24a7f9cbea0ddb52533ff2c2011e5e55ea445855ffcb95d8c69db03996acdd3e5d0c5e011c520635f668445ab58b6e8880a4666596130d2e836397d3c7882cac712395c0bb783d8845f9445a5a3027ac320db074615b4b0bc0dd21e8b0deb0f2d505e45f4bcb1684cf2c99f009748193aa23c7382591398f17272ac712e6a2f748abafdc3b6d3cbefb20832b598749e269252479fa7d132ebcf0a5ee3892ffa70e1a8feaf226d906bc410cd006855a026b3087da06cb82b26f5dc21649531bd21d93697ec0d62223214ed347531f796346a6e7854ca01a3c33907c05f14889563d3c3cd4f2d527003354d0318cb6e80f792b4e00d6376ee9f16d4f48ae5bd75989f633ce82c35735b9cb1028cb76b0eba8068a4571926ffe6d099e7a51d430e294b3301084c90b4042b8e65ec3fcf6a44a57accdd21b3aeec0793fc936aa0588c4c13b438dcb73ac0d1430787973945d9ecfa309c69fee21e448b0005365354fa9303f94fee738f31018e3781b61961388bbc0d6d9a7a2b029c6b54ccc560c4a43980b3fc1775220bf16398efa60d5e1630731f1b3083e390e554d9f0b409cbd9cb397c5d3e4fa95bc827984d29f93171e9bceb444bc1b2e9c56177d40d753938f5d8ac35d3b4965fe52d258aff11919750330f8da1d732d4f01ab1b8ae728c4b6ee05751fbfd78e78276d9ea08b5636c146e5c13ddca1cb4e05a928296ed0bdea3c97695e0bea9ce369d4aed01e9d1098f057a74bdd331749045e995919b52f00f30af1b2d3f06bc2b24bc40134e306268e8da95010c3b089225e1c31fc6c8255ee9a254c9c3d9dac1892d86487bd1af700e05a696539271b9ecbdfd398dd4face5131ef47fe5459cff224338c06c61ead9860c17f04092cb507d9df5f94bfd075b48736d450ddbe09dbc3a1a2bae9b108e2e9584c2c22aeae7adbc06d1b2bf58e81e64483356e279f0e0657ddcaa46bc236930d095adb4825625ec6c431dda95567c697d14c1f51e04965034dfbef87031e41c51e4788726ca62f6d95ad97c536e2b83fc9a85d38c8c0d4c757a8305858ee1ad195b233878e8d4a8c71d49be35a6498d7d541ef5b8e6811f2a917123902cb0b7cc7bcd28c1d141dd7e5519f41f70e64b0ddfb6bbb82c11e7cbc322b1d7f9df04bb85f912ca676022f2001b9d858c79af095a99639afc60646472758942828638d088b30f27f241aff04f94da98f635bad184870d427d5305654600f8063530a885a32c0a12d46be40aa2088ae7c1e84f3228cccfd80df9c7f5d9495e0955c91affab08ff94c36e173cfdbfc57ae392180efa274e535061e2d648f17949a3932de05203a338f4b2b40f49fc47c30b8138ada4decebec1792a8a759a1854f13905b9d5d905322aaabc850e78bcacc21ae14c9cca6f2754861f6513b148d0b254754d7c3c9c5ec0d411dfa237c53ea65c2e4303828fe965c328055cd4ccc37c2d9975697b460eaeff2a83069788369da8a421f74ffb09cf254f443ce0bd82074f9f3ba158bd55e8054da0fe5c73d0d606f1e31b2916ed169c584e1bba91c898d1813895acabeadc8c418ba5d88bcc69cdc2bbdaac9c4127982abe8aa100b38efb9d1da82795d1de2f8de8dde6a3f7722ccdd0b6135bb8c63ebc722ba14f2eb071af35a22e5b067e0c5951bac2f0606749e6aad6f364d133729768cb75e8585d8576278f3d69043cfd6195bfe46a40978dee8b85c3a57a6d232242ea69c3a9cb1b7e8be9d528f9babe7a9d7618c499b33b4c0a66a2d585df8208fbd4072d1b8b3c6444847ee97175accaa87b1b2025333d969ab91cb9330006dd8f4fffe2aadfaa6bf27f95fb9e119ba03566e959c0f14e87a97fb896f31a8f67071a5bb1242d46cd1a96bfc0a584582e17d1672771c8fc10782f5b8f532f8faf7bd2aa18f65fb857b79b9fd0707408266baba4d49ecbbd68928565ef8c73fbf879c493907884cc01c39084b09ed71b7c5b4cf1f15e600957bd3f46149748c15628cb258e55dcf90ac2f4752c2e675e6d798e30389a00cefd0098c239fce642e7ba56da648d33378b15a58941c20b28e682e4655de003d31b69614f27efbd593df785cc41c8ae12c1bf8ba9334f7726b0ee6fd5405b0363f11260a9480bf3fe76748cd0063bbcad781224571077007cad829c0bc70bf70a638cef357d86462c3f4e8c7675cad4dec14a7c72af1410db95f8ddc0207b4dc3768b6caff488319f7875343444292ace5eb4e74d1a144008ebf2e7697c2720c0c50fc1e2885456ad655ab565d9f5b4bc12410ed5c12cf6e336d8924772d52be9c3e0ca2c871261b455aaf914dcac75c56c81ff502897509f374eb9a20c77ff20a7d76654929e15dee2c3ad24b2cccadba68e58df237f0ced75e6848a83756ef509969a3f7c0a22446461a9efac5ed6506df71e9e3b89d9bc1fe9df187ce85294c43c886eaccfc98ef48b09e45ceca553ac66010dfbffa4433cc7f44c2292bfb0fe6ff19272a31ad002a0c9a9e0dd13d11ec9ebe8d6a8d9203937add0bc8c08ed8b900d4efbac42f0803fdad2b40195351495a393339269abfff495f9d15ee84afc34cc34d12a648c2969a5119ac89a924fc0e8ba01839bd5f877a0f4abdaf692f3aeef8f095950745dbb5527ea2733ba052ef27a40765af3fb1c1c3e5ee8591d0c5c2901814046a8ea14e576f449966ee860c4319808fdc139520303ad3b8696e25047ba610ee2d90787747e8b0d491e5c3f4cf05bfded64a79d6de525de31f039f7fbf334f1a0d25d5515fa6c1a710f28e2d41cb2aebf7fb93851ec37a525e143fe0df954a37d0d8bf554167794666a9c97a7d0fac5f96cf3f555430bc25c4ec4fac92d45d55534209f58477a4e7c6084ae358a4a7b6e97c0a0c30012fc12c441893b3ba15004d299813535465ba28d5ce0b3bf48a0d768594ba32b4e7a97c6ca21b0aa9ac44d5c15eab51d0835e8966006ba24d286183c533bfb51a935f6cad06660ffb19d9aca5735dd0709961a4514a2319a13f5c93d0483133135035a4a63aaad1a0221f443ed848cc46bcfd5e3ac128a85b4040d4a529ac17bc2856f034a040f3b498f2ef776d7c6abd315201e75e9b5e02ea77aa247fc405751aaa7c758f75bbb2d61135ebee0d02e3daae99849f464a9e0199a5886e1d75366bd0d812d91d58d7678c84336c7a3946c6d30d4bc4c871cfd58bbce9ef122e3bf4660f07d32125ec2ed39a01e9f10574a3838039a56175c6ebf7b6d85b7ed5840c9b7bd0c2e1fc3ae99ce9c2b71641b0742bb28c586bbefde2add5c1deb28f7c86944334f509e71dc6bd72181676e774bb61ab81f134b7af77e248521823cd11e1e915af383577869782aade87a32a4ae0ba806f39e8d5a0731645c92e261d94c7d596878ef346ef91bcd3fa0038a9c9f16422c03a1e825ed0e8f695be6f1aa5ed55d14e7f726954cc6119d90c863afbf1ec314e302742109e35c45e39f5c07bbfea9d3bf64246815883e7e9b994eca27fee971f593dd80b937c9149589ad5aa4a114bd29a2462a21160ae87335808352140486ddd4c1971d48005e16eeb2d532ec21fae74f9b3e6ab4c6feab9f6d2de0c31bf36bca746d22005925f97f6fe689e037b17ab5875c722b83d9cfc41c5457a817ca15ba09b2a92084935644792e02e19c59cd6cfc8b5c1c684da7db175b1e89c83485bfffa3f4301640f9a44d78eb93ca3f85dc5a12e29df32b95cd108c1e274cc49f92317703b38be442c64b9a2a27936b3e4a198e4586112dfcfcd8e9b7740cb558540999372ade29c3d50aa2a7863a6227e1976df5549b00fd49028d608b030f04be6098a14d506ce316f1ec2f4ab7c591a529c806e486081d55bae5d1df98e5bdd878465f3d180bc8e1378329fc31640205f9f7c478045e31192e5fc9ed0bbc13d4ac911d39d819c8a49687d206c3c2b52dcf13d49e039c3c9e6ee191b94034d0af17e3aaf5db48eeda57a36e68e7e864dc909b534fc4c7697eff2bf31e67c49a873fdb3defd63e074c9b6e28cee82ebe4c2aa2537837499cf6d1afd7ac7cdce8fc0c459f41e874bdce228621745a20fb35e0938b4bdd08b4d550bb1301ce397fa8dbac67d2d1a9fe51a8eef09b551491fa0785451bd3b0a219236d812c2addbef671e7d7d079fddec6514a29a90f5ed352f4d0f43fd7bc3e53d3a2438cf29861684d818d3effd67c80d789d8d61c2a5f57fa605554960a3946fc6b9404b939faaec0b4b6291fb364b13ea6a4c401c3dc9dfe95b73a5e7f4f35f0ff63bfcbc947025ac095c2d8eb3290a29efd7d0b34d48d2e2b611db7a9b2bd6c8b7d45ca679a5eed77df0c093cd8130b144aca18905c3a37fd9c5875efe2cafa1576908b19cc8d72d2d92a5bc05c1761d47fc75f71a6e2640cae0dd09d890ff1188192ecdf19345c4497775d912212519c9ab1e0394282a40ee3771ef91c30db2727cca0d16b807a53735b9b861115105a90ee030a365120260b7f85776f3b0346d89d87521a6f48f143628e03af89650937ca28c13db1e9bfa2b1f70bf8bcf83faa0158992a5c945d82cf10aad8731e189d5aa08045e448680dbd63867e346ebd0338b0884a0fea6458b60173bd3e06589e51e0da066ad362936f0d250c4d2ac14410827c611dd2985b0c2e5b944db28cb58ddffc3d8daf5ffeb177a9a00d25ffd6b917b226939576460a8256bae53b71b115f65aa0e029fb8f4b3291531062763a2faa14f0a9c3d240c7ded049cce0f42c266ae787361bc73ef70886d93a8ff8c7f4471f23b93017ae49b7eaa0608539c429d70ee977b99162903f594666f20df061562da593b7c72e335f0dee9733b6a4c830d621a5dafc71a6120a2d12bbe4686882c9e2ebb9269dbfc2fac173b3e7cd441f4372c4b88578f41dc64792321fb1631a296fcec8","isRememberEnabled":true,"rememberDurationInDays":null,"salt":"6e9af43db40eedccc0ce44bf62d7d116"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
