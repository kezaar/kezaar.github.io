<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Locked Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:description" content="If you're reading this, you are not invited and this information should not have been shared."/>
    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            font-family: 'Courier New', Courier, monospace;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #db3538;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #ff0000;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #bababa; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #bababa, #bababa);
            background: -moz-linear-gradient(right, #bababa, #bababa);
            background: -o-linear-gradient(right, #bababa, #bababa);
            background: linear-gradient(to left, #bababa, #bababa);
            font-family: 'Courier New', Courier, monospace;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid rgb(238, 31, 31);
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Page Locked</p>
                <p>enter the passphrase you received</p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="passphrase"
                       autofocus/>

                <!-- <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label> -->

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"c1c2291045ed4974ba762db116f1506fa4da5af7a586991eca01ae61465c61da89c0ab7bf70099390b08ebfbf727779a6dbb7f52516789acd756b6168c34d0f341369dbe4d93650740afbac5962a2955508525cf8a739ff76720f516c638172b37067078bbbe537f1d3c61b4d0661497058b898980858b921760834963e85f90addea0fa15f5cb936ae7182513cff02e28a2ce73e0b325341790072d8c360ea1871ab34d2b6c3f950593e0fe4e5f80594001482d0d394b661966c2c25ea84d5d84529e9ef1250543303a19eed61d843b6e9b0d1fb4780a33bb39dd1a0ed90460703574f0425e5fe714ec47966586a38af1adfaa023390a5910a4129b849a368ec3c74841e553e975a23f536445e61d840fce93d92531e37ab4a2762d6dd53e92418690437eb514f679b58c99f71662b720ff543159199cf62adadf841656cb9ba5042dcc54adf0b1f57a311001ddc4dffd8606a512393650271421567945cf989bd8c26a1f77aa7508110084f4a0d08296da21bc9eafadc552fde3e1e2cf25eccfeaa114368941fe6d32caea092ee732dad757d108f764a50b612f6ae5ffcc92657bfd3421c0cdf94bde8ddf3ce7cf3d27508d05b23b09b040bb25bcdffafb47efb72c64f1384f13e68ebbfc572277f793df4b3bb7ff7703964e507d9139dd245f8e747c85ec97a010365403557c2a41ebf3ecad2e107cc5a233f75afc5f2ee2845bb586b60e0d3bc53a919dda82dd8b2f457057f645db754a8ebb01f566e4549a68a67ff34da26eef356371532110de4fca751c70079d475924830d2d979a979222b7132f9c56f72c0e39ba44d72b2e739429f207344fae431e9007a44b169ca664db49beb0831cc2e0c8d87e96075c27340a71ee930cd4587db96dd8e6513ca0ee6e014eee65b38fe4efb26dd53861b32176a0c32a3c109cdfcd7a6ffbb2d9afcf75647d0f2ece029069511a398885867dbe7deb1d9f9b93be05eaa7160b281a09ead0c321ecbc1b7fe6f37b3920041ae29a89e39b0ef4a566d4d665a98d59bb32050b5349c60756a6bd24ae7bceb964f761a0a31e86965f5b061b29b1e707b1c20c7caa1b98771165415387742d2f702cfec2cba4114a34f05dddfc584bb0974d54588c9506fee2e34d8635103e3cd4638a79b4452e849a92cbcc2720cb8ce09ea1fedbec17037e7f02e206b968c222270f22f5953b6af1d9b2b72f4f4a3a679a7fd469f9e2de0ac9f7e66711162d1f4a1f214b70ade73e1893f65a4c8b730650d60bb0d289e8e502ece4fc7914a6d2fb8fcc2c5a18aeb7cadd27bef2bc66beb82c6423b15f37494635750ea850f0424bcf7299f6051a444f081ee9cce7a70aa414c6aa73f2153bb67128d853de3f55f777ad41a7ae994d3a044fcb41d24dca5022e5207e9a85c9d34b2ca095d0d12bfa0745a5b3af556cf0c14eb40fe050ddb281abaa6048c7952d442a3aae480ef71497a14d07cd8e4e9bf1435e61b52fc04eafb3a87e617ba3db42ba5854ae0795aac436c61ad038775740b1c49e5f15daaa66dbc92fabb074abd94bdd9997a268ef24c0a172b4b7cbbf2cf032a7268a693f32735317409972ff92d35403acdbb19a12e1e9bc4caae48a4f1293de4e7df57dfc7f7cbf86a79330297504d185139481331f12a5163f5138f3f68fa5a61e060e159ba7e8b22988f566c34880004171706990b6f5a28c4400f7547cc1da76dce2c551f897028f2b192f2169340c703f455cc56149216f405155d49d45be9d998c456d9af5cd56cbb078881e5e7641119d541da049a9b8012ae9ca7ad41d3db3ec89cf6e33e221b2f60313083e317c8c0a31a35a9de8d5ee6b512d18f9f924f38cb2d1bf910afffe544cd6b2ea27a800e00ee70995077bfffe2f374551beeefa39dc21c435584c779d9d4db86f6f798be7646dafe276e01ad9fe255add5ad59fe75165d9372c83bbdc23ab5a924be102498299f4f6a939dba9108fbb407e8ed9e6323b8d6e67cd6647c7180b1c7921394b9abbc4fd234d702a4d2c8296753a50420065724b7edfbc72c68f99078875f7c96412ab0110f3eff471c86393a5391973b8a89a8cadc89cf4f44671b6660e6b36d5706c1724770419be6122f59f16cb4ba472964f11fd215947f2b0067022276fb0d6ea0f3eb90956cc13c87f39d4c34a2a32ec6b74aa7349ffae396ef0a5ab2a28234521163851fb5b124abd096f2a430a35d591cb0b0a16d50e0a00843d46f76739dde1b465a5247fa9765a9bf980acc9d38f1689a0510e22bc7295cc39c5d7b769baa8934a687d8b923281049e49f5b2c41ba65078a018f0aff3c8401d11c6bc84e048459897e9107ba2e1ba2a2da4014da14949c2e453736abf2f494490893c30b1649bbc6f76ea2a15edd4c99b2cb9a848f7b4ab0702e35ef30a2acdffc72bab0320b52330605fc5e967b333f97ccc16addc8356497e93bf079554ffd6c9f791d8d1d4b955007b42e77658d73a3ed376d45d40bc8c1600052cbb7ee48889cf5e0e4a29869a2841657f9bb6983f0e71ff077e6bd810a55d757739a1746ad4629ac8b1fcdc8d86dd5bdc8a6767c5d10d75f2b25365464fac72867b89d45f4d1b89bc2e64f4c444a16830fe33577ff9d7fee49209ec5fd73263632c633a2a9f9427cb388b104095ce202fe99f55c08afdd81312d5dc02e9e38488c384ee915ccf3a5984dc3adc15df2198cea3fd9187df384add52a08bab2b467b892330ce2b0621a918e3a51435402e8527a774087e8d248389222639646f6d675ff909bdb2784b4e8b802058d905e69d8032d836d8a0f3ee1cb216490f4ec60cbffffe4fb39b203dc5878e79048a1ca3578b8f713f2772a813165e57a5f3df86aa446218645b7066b0275983a9d2e06ce3b1b2e4f1dfcfa1771b6d5a376a49b643fde2caee01ee88d8512810858be87d88573af9b9dd61fb9d35586961496021352361443e06dd3aef5239d3df17773107a9bf41b797c347a273d355ef294fa456ad0635151a6a45eeba2b33ddd7b09a918d0d66472c086c0e075ccadf0882597d03550fd76498231a2bd9b7610f720dc83b44b2dde43bde0b5fa015946a2e6f433e79f157e81a292a0a8b402c4c0a29b64f57281f77f751bf2e34bbc5044b387abfaa52fb425a6d5c1ba5f93b7205c30498fad3664e7697bb1fc1c343bd0dc647308d4fee08e615cce81b971592d86b8827d725aa500c47433d2495d6a2989df0efbb18a399d05f187f214a25fa94860261354177e47a73fc19da21fdf7aa990b57b311c89ecf5bd8114c878210274821b689709d1c6a74d532f7f167165186ef6e3a822fc01e8b93472d675ec1534220c1906411434dff80223598b1c2a433fcac4dfd97f98d579a42554ce7b5d6a03ccc28d47b8549f1cfc6ca4d2666bf1f514f66dd1fecdb6cd2e4f73243d441933536679630777b491830db5c81445971af18dc35ec5916c77f51ddca1450bcf8d16bff67c2e1fb41a2215b47cc305ef83ab0814d18c058211cda78b6f8ed7dfc69ff3cb9f76a7b05a6dde88a40394807f906f6364234367d77352db0a8abcdcd77a63577c4cca1740b470a99f6eec924004a8bffda9cc0b2d15b074cd7ac2e03853368b743c581334acc19cb75c620db158097a0ab16a8e1a0b26ed4639892c98291997129d7beb57ff22f5e895cc9a3d4955a9799e357717c2b924f2eaaf6afe2aac22bc7b5fc36a61569fdebc6c100928f00121fda72906ba2b69a72af9b1480cf2effe15b9b12ea65564778d7d0d595b2e6764eb4a7f7289469364b27d1d129d7de39e388d309502a4f538c9f02ffc3f1241193d6d95d6c6ef8b85cc844e9e99e88f13099fe5f3480b332e0dd02d5b92223e49bdf6a60c518376e03db3a4753c5e740bcf335b2b4af8319f2b7ed62142762f986b393bb3f84b683788c3e4c46719165976a5db7b39392726327c3a8f7b21ed0eb97336a39e6faa11557490210e9a0e1f3066880c11f106a51277a87b60dd46bdf9ee5b6a5d41c4ce8d6f8af66309714ec7e62d82ef3af9186b2a18f0922ece668ced832a94351c41c02066de04d72c3b2c2af6fe31545eba028a6284fb721a2fff284da8cf9e22d4f83bc8413167ac89c3ce12ae6f6be1466d3e78687958d8d1c03d8eb3fc0c11865c921832d6cb2acf7588a7109f8d7cdaf9da3d1b89c79e481807b7a5302542f54404c1ce834e3f73414dbc3a96f442cf7cc991ce75e8718a0f6a21f5e2828b53bf5568eb782dd25680f3cc7600c0b122a1d41ef5e40f3034dc8ab51573b11883317c96db865da7c0b5101da72a1064a4fdf3434d70d192bea1fe674b11f022457b3621ebca06173458545fd8bd9b8ac05dede9ed9e5276f897579334ae10a7bcfb62c6c224ad66d36a9b42cab66395b560853416b7c1fda9c957341e0c9c89dfd775f4647b843564457cb354ac141fc956a0b8ca1478601fff5ae5e9c59aa9deeab741e822e52b0a4a7dadcee01dceb70d61893b8c61e41394a32c3d5f6b020fb283fab8c43cc9709780bde4984a7e858dc432980117e959576065779cf1de266d2665ad02ecfa082759e73d712920946a7e22d6c34754883f0fbb708af251fbd1ac8a335d87f0cd429d59dd0285488db4eab1a3681f730dc6aba674d1756aea409fa09811c7021ed9f0fc49f01b408f011774c483b982cf671320d40b59f6582418b58cdc1780c6b98eea14ac6fd263a5923630bf6c4669d6844e4083388a7d26b5ace8fceb5c4b5fc46366a2c199ad92af40c91bee123d2e74ecac4ada6d6fad33209b0a72b5b458448645da10285ae86dfa3f430ca5508468b87d9a6f90a886404b6a7672c189a1ecadfea4c2835f4d3f94d373fe482bf82b5b816ab915709c761611908188377f7c3837815531e9b017db72d26d73450f7c187c909d7258742e97c725f35e94f268bbad5307e99b2e646acc49aaed942a76f3a065b1f21bead36171c3bebcafff2d5eee19af22816a504a302d9324fbfacc54af549fcf2b31743a275dea081994d3b901633ae1c109358bad705e3365f8b3f715515d772f69fdc0db3d1a44f4aa93879d32d7df1c745eccdd370824790b1b4127fd40c352a8fc99f698727877bab98711eee3f9d4fc955781cbe9b59c304cf5259e0fbf8b1202038f5d12a924bd33d574e1a575f6fd7e6f2010c91c9301e80d4efb01d8234272184ac263379bf3f1c83d38ecbff4c91bfbb35481d70e7cca642547054e284cf6eeea4a216216eed1f389b38759ce40114efaccddcce5cdec9c47cb291c224ff67c6a8885a8869319abcec7a6a8496728f28371ee78d5eaf32fe39f199c9a5b722fac95319c9edbda8eb8ddf55959ed9470f814a9932b2780e9c7e5dc4179ee6d88f81b39432f5ddbf6d9ce2c76c00d6e35518a2fee162e45faba25e389b6bece1465819662e226af1baf7eb08cfa14b17341a545a5935f36ce82d3cc316ba7bac49639943d0c004f6562549ae6ba487fbdc9bb0500838489e1b6137d78408548eb0e12708a0918d92df0dab9f1235396ed64c194f3697a12ba2606be3587d3667e33b4b83135b6e4740c456a30b6449d93470e3e7f4a9b1ff334cd2328e9d0ec92f765985c0d6ebbd3349c770762d853072d1e35d52cbef02ac1726f39c8d1d7757e1a94d6759efff3ebbc2642c3ec7b377436c77a04dc02f3f926dd944a2c0083ee40785c45158713b930b4a99871a76a42deec244f14356c4d7c6ea6a4c3344ec5b11859d8e2de52b500ee5c61ea7413bf355d7dc02496f4b4d1650692db8be9753c06100993c69a7ede1c3cd846bb6a5f56a24ec68a9f68129b8e27319c43b1349682123584a4f9592da8cc779becc7e6c8429aa6792e6b9797eff99627c15cd069b27e9f1ceed147650969ced74cdad8e8d313d9f44d65203cd192af5ebfcdc0950a05d4c27a448e10dcea3cfc427dd5238452728b8870e6273d3de3ad2485977a37949beee90313dca151eab7d7e7d49b0d5ed1c3af7eb68147508574b87a4836f9340176400581f56cd4c99c499563176eca3eec86b6aa90d03f8c7664460cfd5b401eb4caa9e645d9d1936a24ed8925b71b49dca14d56ec2aa6d9b6a8fdd2394bc63e5c85bcf9bb0e4aa417e971613ae2918d7f96159d77afcfa2530135fd736d5c81b3528a25c7eb0adefd67392b2cf210cdd0f07a1bf895592ea45ee5dd67a5b7ca822cdbb6173bd2bb9ee89679a2cfec480049669114e9ab0da68781a2a92c933de54ce02dd0ddb604abb0638cc75f8c7edfa81e8db4c1b3b145a9e61401d1ef2743742c4750fa1c451dde659ababae90c3483c51508a50641b02e7d79958ef81ef7bfe4318ffa7235e18962b4edc9c111da3247e856a7c0320ac2687776f6a14c278bda1b1de1795238b9a5f1e79723f53a688061d3a512d79d5eb96e279fe340730ae494fc681f16ce5706a847feb352fd3e008c19e7d9679e3facd0c7f5fe19a094f106b3b81ecb044d4248c301a21675734bfe30aeb7e6e2c2f6fe1ee55c8e60adefea2f382e7bfd36a77da0dc02e1f4e20f8849fecc1a784759595657a384250809b8719654fbfaede5f788450e4ac5cd3352364536f490d13e94979553171e0f3622846f43d98fde75fdd736ade06926d273b257830c55c2c795b61427334e975936890c9689c47a154321b1225c95bb41f56abe4f5d42a83b5700f35d85603df26a54dc623e62ae57040910c7ae412ca149c634ab9bdb0db5bbbba9c4450740eda3422babf8a0d15086c4dc821e0dd73ab69c0ce74e11aeeb301f76d273ac94953c14c2af3d959ec910d616cb1e0594afb7b02da9f822e971a815f9f0becc86331d417b558036dd1d5be1c974791c9a4dd808d96375279f4bae26f80f2b759b8577f8c53638bcae57f421f0ca1588b7b08958d6c0d29b8860262cb3fb2f70ccd6108d7de019c6e8413371f6ca7555e60be6e534a6c71cf5f5855f75a736a80f0b75f85d04a12f348231ae5fe9ea6fd424237de2f486332d9ce34cf6038f2c76860133bea8fc3385d4df9acef0eb2d4e2424e0ed4d26068d96bb225763a27e203229fd5a3a490dbba9efa1cea7be7c775d8015a12af0ff72a08f95de9fb49ff1058f882c14385675cb05d2eafb9959cca749ff603ab0c20cf2fbae518c7cd54b22c4254b5aaa16baaca6b1cbee8f3a7d78b115d119dac26b66e4ede30133dea8309e74c31e73c49633e8b9b710ca6a4e0cc05971df03fd9b8bc97e39d225bc0954a6ecf056316a4f4cfe7912464a0c191345749a0576ce74308c4ac6761aabafc3a4cefb81d3d03d4491d80b22e3128f91c80d9d3559158dac5c59e02e2c5f645cd890ce3f625cf350b435a96ac743314f771e7c2b8c41e0c75a94932d3588fdf264fa8ac4bb7ea3dee52992f749d86385b38c12beeff670865904c9714714d5005ec0176a309e5a06c22dbc0fba4fbc89219ace04108a914262b999b94192f72298bce3bec2337581769c26dfdce2f1ccac1126af255df6e08e2073d9212a7c9e1a4d1596ced4a5f8fb168f8321520d3818a65a37d86c23c9ec6d1d96fdef8755f486390de4dcab5ba30266bf2b704ae8be5eb03a9a405a56cde6a33c289e52b7ea3b3749ba0a3527705e98d83163bc26ff6b8af1fecc95c2bd0befed94d98c19fa88746f362d98136260c3269b9a56b4b53e86cb4b38863ddfdce89e278951afea907288149b8a358f0065630a1d7dce461a8155882dd19b7463a621e70723f4b94e81fb085dcfa17585d645366629898ae951c4a081cea3cf6bf7dc7a299d29f4ed719f44e1dfaf9c8d400d6d0484ef941c8cfc30994390858d13fca1888b7c866fe3dada0be2a0bdd52bc46b689473db7a0023d9fb5b5ffe0742419d3c0bcb534450846614c2334aea893961f54f7eb86a8ebbb31b785afe3c4529619139e27a63c34f2c53ecd066d29239a846044fcb412f92ec23e3c0d4e4e06da2241de8d56cd73515632cb5e705f71ea1b80776797d0766ef2e74e8f07946cbe2cbfe9d16f729eaf93493e119c79f25452567eb48a9a9c01d647cf80ec96e44197ff4eafd6653097f9e548df74d5d2cfdb440217eebe67d18a5e1ed58e79de639eff2e76dd1d89b79d4a86d8143db3a6111950cd5b8d36073dad1e03ba12ad2fcfaf4dfaf731d2cb1b20a9e1021a0cef8dd130cce79fd358b14edb20eecdf70d1d10093722160806e123e0a594c878ffaa475d0b86a78edc8c16cc870bfb444ec58c11ecab1e1144323b7a8004cfbc6a39998459797922ad3b1d1221f7f2a31b234ff652edc7836bdf9c0febc8148d3b7fe6a7cb5eab938b6b11e1adbb56c1f5967aac803257ec20da02e8ce47efd67f729263f3dfe9f4fd35098fae7f6cf840f54e2d34f58827ab6f677ef8c314c670aa2f1747560d30a53e8161322b84b7a851bd840f0e67ff7c7505455ffb98c9","isRememberEnabled":true,"rememberDurationInDays":null,"salt":"6e9af43db40eedccc0ce44bf62d7d116"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
